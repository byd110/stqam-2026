\documentclass{beamer}

% TODO: print out https://www.fuzzingbook.org/code/Intro_Testing.py

\usetheme{Boadilla}

%\includeonlyframes{current}

\usepackage{times}
\usefonttheme{structurebold}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{alltt}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usepackage{amsmath,amssymb}
\usepackage{rotating}
\usepackage{ulem}
\usepackage{pythonhighlight}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, 
do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]''
}

%\setbeamercovered{dynamic}
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\usefonttheme{structurebold}

\title{Software Testing, Quality Assurance \& Maintenance---Lecture 11}
\author{Patrick Lam\\University of Waterloo}
\date{February 9, 2026}

\colorlet{redshaded}{red!25!bg}
\colorlet{shaded}{black!25!bg}
\colorlet{shadedshaded}{black!10!bg}
\colorlet{blackshaded}{black!40!bg}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\newcommand{\rot}[1]{\rotatebox{90}{\mbox{#1}}}
\newcommand{\gray}[1]{\mbox{#1}}

\newenvironment{changemargin}[1]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{1em}
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
  \item[]}{\end{list}}

\newcommand{\brac}[1]{\texttt{\textless #1\textgreater}}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L11/06400_big_and_small_sheep_v2.JPG}};}
\part{Reducing Inputs}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}
  \frametitle{\LaTeX~errors}
  \includegraphics[width=\paperwidth]{L11/latex-error.png}
  \begin{changemargin}{2cm}
    \Large
    To ask for help on StackExchange, need a \alert{Minimal Working Example}.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\includegraphics[width=\paperwidth]{L01/00856_destroyed_bridge_ribbon_falls.JPG}}
\begin{frame}

\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Fixing a bug}
  \Large
  \begin{changemargin}{2cm}
    \begin{enumerate}
    \item need to reproduce the bug, so need a working example;
      \item better yet: a \emph{minimal} working example is easier to deal with.
    \end{enumerate}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{MWEs and Fuzzing}
  \Large
  \begin{changemargin}{2cm}
    Fuzzers produce large inputs.\\[1em]
    When input contains extraneous context, \\
    \qquad hard to understand what's happening.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reducing an input}
  \Large
  \begin{changemargin}{1cm}
    We'll show a way to \alert{reduce} a failing input:\\[1em]
  \end{changemargin}
  \begin{changemargin}{2cm}
    ``to identify those
circumstances of a failure that are relevant for the failure to occur, and to \emph{omit} (if possible)
those parts that are not''
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Mystery}
  \Large
\begin{python}
class MysteryRunner(Runner):
    def run(self, inp: str) -> Tuple[str, Outcome]:
        x = inp.find(chr(0o17 + 0o31))
        y = inp.find(chr(0o27 + 0o22))
        if x >= 0 and y >= 0 and x < y:
            return (inp, Runner.FAIL)
        else:
            return (inp, Runner.PASS)
\end{python}
\begin{changemargin}{2cm}
  Fails on some inputs. Can use \texttt{RandomFuzzer} to find a failure.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fuzzing a Failure}
  \Large
\begin{python}
def fuzz_mystery_runner():
    mystery = MysteryRunner()
    random_fuzzer = RandomFuzzer()
    while True:
        inp = random_fuzzer.fuzz()
        result, outcome = mystery.run(inp)
        if outcome == mystery.FAIL:
            break
    print (result)
\end{python}

\begin{changemargin}{1cm}
This works and eventually finds a failing input.\\
(Manually, took me 6 tries.)

\begin{verbatim}
$ python3 mystery_runner.py
(%*50  1)-&7,;49:4?%:43*(-.
\end{verbatim}
  But why?
\end{changemargin}

\end{frame}

%\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L11/06400_big_and_small_sheep_v2.JPG}};}
\part{Manual Input Reduction}
\begin{frame}
  \partpage
\end{frame}
%\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Divide and Conquer}
  \Large

\begin{changemargin}{1cm}
  Kernighan and Pike recommend:\\[1em]
\end{changemargin}
\begin{changemargin}{2cm}
  Proceed by binary search. Throw away half the input and see if the output is still wrong; if not, go back to the previous state and discard the other half of the input.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Does this work?}
  \Large
\begin{python}
>>> from mystery_runner import *
>>> failing_input = "(%*50  1)-&7,;49:4?%:43*(-."
>>> mystery = MysteryRunner()
>>> mystery.run(failing_input)
('(%*50  1)-&7,;49:4?%:43*(-.', 'FAIL')
>>> half_length = len(failing_input) // 2 # integer division
>>> first_half = failing_input[:half_length]
>>> mystery.run(first_half)
('(%*50  1)-&7,', 'FAIL')
\end{python}
\begin{changemargin}{2cm}
  Progress! Halved the original input.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Failing at Failing}
  \Large
\begin{python}
>>> quarter_length = len(first_half) // 2
>>> first_quarter = first_half[quarter_length:]
>>> mystery.run(first_quarter)
(' 1)-&7,', 'PASS')
>>> second_quarter = first_half[:quarter_length]
>>> mystery.run(second_quarter)
('(%*50 ', 'PASS')
\end{python}
\begin{changemargin}{1cm}
  Same trick doesn't work again. \\
  The code says it's looking for two characters, \\
  but in our test case, the characters aren't in the same quarter.
\end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L11/00219_falling_rocks.JPG}};}
\part{Delta Debugging}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{A Change in Perspective}
  \Large
  \begin{changemargin}{2cm}
    We tried direct binary search---didn't work.\\[1em]
    \alert{Delta debugging} is another way.\\[1em]
    We instead \emph{remove} smaller and smaller parts of the input,\\
    and see if it still fails.\\[1em]
    Intuitively: more likely to keep the brokenness.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: Removing Quarters 1}
  \Large
  \begin{changemargin}{2cm}
    Let's start with the first quarter.
\begin{python}
>>> quarter_length=len(failing_input)//4
>>> input_without_first_quarter=failing_input[quarter_length:]
>>> mystery.run(input_without_first_quarter)
(' 1)-&7,;49:4?%:43*(-.', 'PASS')
\end{python}
PASS, so must keep 1st quarter.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: Removing Quarters 2}
  \Large
  \begin{changemargin}{2cm}
    Now for the second quarter.
\begin{python}
>>> input_without_second_quarter=failing_input[:quarter_length]+failing_input[quarter_length*2:]
>>> mystery.run(input_without_second_quarter)
('(%*50 ,;49:4?%:43*(-.', 'PASS')
\end{python}

We knew this already: \\
\qquad \qquad must keep the first half.\\[1em]
We also know we can discard the second half, but let's see.
  \end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Example: Removing Quarters 3, 4}
  \Large
\begin{python}
>>> input_without_3rd_quarter=
     failing_input[:quarter_length*2]+failing_input[quarter_length*3:]
>>> mystery.run(input_without_3rd_quarter)
('(%*50  1)-&7?%:43*(-.', 'FAIL')
>>> input_without_4th_quarter=failing_input[:quarter_length*3]
>>> mystery.run(input_without_4th_quarter)
('(%*50  1)-&7,;49:4', 'FAIL')
\end{python}
\begin{changemargin}{2cm}
  This doesn't tell us anything new, \\
  but we're sort of following the algorithm.\\[1em]
  (The algorithm doesn't actually quite work like this.)
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Infrastructure for Reducing}
  \Large
  \begin{changemargin}{2cm}
    An abstract base class that doesn't really do anything.
  \end{changemargin}
\begin{python}
class Reducer:
    def __init__(self, runner: Runner, log_test: bool = False) -> None:
       # ...

    def test(self, inp: str) -> Outcome:
       # ...

    def reduce(self, inp: str) -> str:
       # here, non-real (abstract) impl
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Caching}
  \Large
  \begin{changemargin}{2cm}
We can cache results:
  \end{changemargin}
\begin{python}
class CachingReducer(Reducer):
    def test(self, inp):
        if inp in self.cache:
            return self.cache[inp]

        outcome = super().test(inp)
        self.cache[inp] = outcome
        return outcome
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Actually reducing 1}
\begin{changemargin}{2cm}
    Here is the outer loop for delta debugging.
\end{changemargin}
\begin{python}
class DeltaDebuggingReducer(CachingReducer):
  def reduce(self, inp: str) -> str:
    self.reset()
    assert self.test(inp) != Runner.PASS

    n = 2     # Initial granularity
    while len(inp) >= 2:
      start = 0.0
      subset_length = len(inp) / n
      some_complement_is_failing = False
      # inner loop goes here
      
\end{python}
\begin{changemargin}{2cm}
We initialize \texttt{n} to specify that we divide the
input into halves at first.\\[1em]
Also, we set the subset length to the current input length,
divided by \texttt{n}.
\end{changemargin}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Actually reducing 2}
\begin{changemargin}{2cm}
Now the inner loop:    
\end{changemargin}
\begin{python}
      # remove chunks of size len(inp)/n
      while start < len(inp):
          complement = inp[:int(start)] + \
              inp[int(start + subset_length):]
          if self.test(complement) == Runner.FAIL:
              # save the failing test, decrease n
              inp = complement
              n = max(n - 1, 2)
              some_complement_is_failing = True
              break
          start += subset_length
      if not some_complement_is_failing:
          # all subtests pass, get half-as-small chunks.
          if n == len(inp):
              break
          n = min(n * 2, len(inp))
    return inp
\end{python}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Running the delta debugger}
\begin{python}
dd_reducer = DeltaDebuggingReducer(mystery, log_test=True)
dd_reducer.reduce(failing_input)
\end{python}
\begin{changemargin}{2cm}
and there is an example run in the \emph{Fuzzing Book},
which I'll show excerpts from:
\end{changemargin}
\scriptsize
\begin{verbatim}
Test #1 ' 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 97 FAIL
Test #2 '\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 49 PASS
Test #3 " 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69':" 48 PASS
Test #4 '50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 73 FAIL
Test #5 "50#7*8=$&&=$9!%6(4=&69':<7+1<2!4$>92+$1<(3%&5''>#" 49 PASS
Test #6 '50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+' 48 FAIL
...
Test #23 '(460)' 5 FAIL
Test #24 '460)' 4 PASS
Test #25 '(0)' 3 FAIL
Test #26 '0)' 2 PASS
Test #27 '(' 1 PASS
Test #28 '()' 2 FAIL
Test #29 ')' 1 PASS
'()'
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Solving the mystery}
  \Large
\begin{changemargin}{2cm}
Answer: system fails on an input with a
\texttt{(} and then a \texttt{)}.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Delta debugger commentary}
\begin{changemargin}{2cm}
  Wouldn't want to do this manually on this input:\\
  \qquad random input is harder
  to understand than a human-generated one.\\[1em]

  Assuming that the system is deterministic, we
  can run the algorithm and get the answer. \\[1em]
  Also assume: test cases can run quickly enough
  that we can afford dozens of iterations. \\[1em]

  These are the same conditions as for fuzzing to work well.\\[1em]
\end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Commentary continued}
  \Large
\begin{changemargin}{2cm}
  Implementation checks that the initial test case does fail.\\[1em]

  Delta debugging is best-case $O(\mathrm{log} n)$ and worst-case $O(n^2)$.
\end{changemargin}
\end{frame}


\begin{frame}
  \frametitle{Minimality}
  \Large
\begin{changemargin}{2cm}  
  We get a 1-minimal test case: \\
  removing any character is guaranteed to not fail.\\[1em]
  In the example, we see that the single-paren cases pass.\\[1em]
  This is a local minimum: 
might be some other smaller test case that one would reach with
different choices.
\end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Advantages of minimality}
  \Large
\begin{changemargin}{1cm}  
\begin{itemize}
\item reduces cognitive load for the programmer: \\
  no irrelevant details, easier to understand what's happening.
\item easier to communicate: \\
  ``\texttt{MysteryRunner} fails on "\texttt{()}"'' vs
  ``\texttt{MysteryRunner} fails on 4100-character input (attached)'' 
\item helps identifying duplicates (to some extent---
  assuming failure has a single cause).
\end{itemize}
\end{changemargin}
\end{frame}




\end{document}
